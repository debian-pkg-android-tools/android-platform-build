From 10e18cfe696ea6eb47e655266f4ac1da70c13fcc Mon Sep 17 00:00:00 2001
From: Hans-Christoph Steiner <hans@eds.org>
Date: Thu, 11 Feb 2016 14:57:45 +0100
Subject: [PATCH 1/1] add -t option to zero out timestamps for reproducible
 builds

Most Android APK builds are quite close to being exactly reproducible, one
key failure there is the changing timestamps.  This adds a -t option which
resets all timestamps in the ZIP headers to in effect zero, but a slightly
different number to be safe with all timezones vs. the earliest date that
ZIP can represent.

This could easily be extended to support the standardized SOURCE_DATE_EPOCH
environment variable.  That would mean that zipalign seens that env var, it
would instead use that timestamp in the ZIP header.

https://reproducible-builds.org/
---
 tools/zipalign/ZipAlign.cpp | 25 ++++++++++++++++++++-----
 tools/zipalign/ZipEntry.h   | 10 +++++-----
 2 files changed, 25 insertions(+), 10 deletions(-)

diff --git a/tools/zipalign/ZipAlign.cpp b/tools/zipalign/ZipAlign.cpp
index a2dfd02..6a5ca1b 100644
--- a/tools/zipalign/ZipAlign.cpp
+++ b/tools/zipalign/ZipAlign.cpp
@@ -32,13 +32,14 @@ void usage(void)
     fprintf(stderr, "Zip alignment utility\n");
     fprintf(stderr, "Copyright (C) 2009 The Android Open Source Project\n\n");
     fprintf(stderr,
-        "Usage: zipalign [-f] [-p] [-v] [-z] <align> infile.zip outfile.zip\n"
+        "Usage: zipalign [-f] [-p] [-t] [-v] [-z] <align> infile.zip outfile.zip\n"
         "       zipalign -c [-v] <align> infile.zip\n\n" );
     fprintf(stderr,
         "  <align>: alignment in bytes, e.g. '4' provides 32-bit alignment\n");
     fprintf(stderr, "  -c: check alignment only (does not modify file)\n");
     fprintf(stderr, "  -f: overwrite existing outfile.zip\n");
     fprintf(stderr, "  -p: page align stored shared object files\n");
+    fprintf(stderr, "  -t: zero out timestamps for reproducible builds\n");
     fprintf(stderr, "  -v: verbose output\n");
     fprintf(stderr, "  -z: recompress using Zopfli\n");
 }
@@ -64,7 +65,7 @@ static int getAlignment(bool pageAlignSharedLibs, int defaultAlignment,
  * Copy all entries from "pZin" to "pZout", aligning as needed.
  */
 static int copyAndAlign(ZipFile* pZin, ZipFile* pZout, int alignment, bool zopfli,
-    bool pageAlignSharedLibs)
+    bool pageAlignSharedLibs, time_t timestamp)
 {
     int numEntries = pZin->getNumEntries();
     ZipEntry* pEntry;
@@ -81,6 +82,10 @@ static int copyAndAlign(ZipFile* pZin, ZipFile* pZout, int alignment, bool zopfl
             return 1;
         }
 
+        if (timestamp) {
+            pEntry->setModWhen(timestamp);
+        }
+
         if (pEntry->isCompressed()) {
             /* copy the entry without padding */
             //printf("--- %s: orig at %ld len=%ld (compressed)\n",
@@ -126,7 +131,8 @@ static int copyAndAlign(ZipFile* pZin, ZipFile* pZout, int alignment, bool zopfl
  * output file exists and "force" wasn't specified.
  */
 static int process(const char* inFileName, const char* outFileName,
-    int alignment, bool force, bool zopfli, bool pageAlignSharedLibs)
+    int alignment, bool force, bool zopfli, bool pageAlignSharedLibs,
+    time_t timestamp)
 {
     ZipFile zin, zout;
 
@@ -157,7 +163,7 @@ static int process(const char* inFileName, const char* outFileName,
         return 1;
     }
 
-    int result = copyAndAlign(&zin, &zout, alignment, zopfli, pageAlignSharedLibs);
+    int result = copyAndAlign(&zin, &zout, alignment, zopfli, pageAlignSharedLibs, timestamp);
     if (result != 0) {
         printf("zipalign: failed rewriting '%s' to '%s'\n",
             inFileName, outFileName);
@@ -228,6 +234,7 @@ int main(int argc, char* const argv[])
     bool verbose = false;
     bool zopfli = false;
     bool pageAlignSharedLibs = false;
+    time_t timestamp = 0;
     int result = 1;
     int alignment;
     char* endp;
@@ -260,6 +267,14 @@ int main(int argc, char* const argv[])
             case 'p':
                 pageAlignSharedLibs = true;
                 break;
+            case 't':
+              /*
+               * A magic number for the earliest UNIX timestamp that can be safely
+               * represented by a ZIP file. It is not exactly UTC 1980, but instead
+               * 1980-01-01 12:00:02 so that no time zone oddities can cause issues.
+               */
+                timestamp = 315576002;
+                break;
             default:
                 fprintf(stderr, "ERROR: unknown flag -%c\n", *cp);
                 wantUsage = true;
@@ -290,7 +305,7 @@ int main(int argc, char* const argv[])
         result = verify(argv[1], alignment, verbose, pageAlignSharedLibs);
     } else {
         /* create the new archive */
-        result = process(argv[1], argv[2], alignment, force, zopfli, pageAlignSharedLibs);
+        result = process(argv[1], argv[2], alignment, force, zopfli, pageAlignSharedLibs, timestamp);
 
         /* trust, but verify */
         if (result == 0) {
diff --git a/tools/zipalign/ZipEntry.h b/tools/zipalign/ZipEntry.h
index 7f721b4..0ba48b7 100644
--- a/tools/zipalign/ZipEntry.h
+++ b/tools/zipalign/ZipEntry.h
@@ -93,6 +93,11 @@ public:
     time_t getModWhen(void) const;
 
     /*
+     * Set the modification date.
+     */
+    void setModWhen(time_t when);
+
+    /*
      * Return the archived file name.
      */
     const char* getFileName(void) const { return (const char*) mCDE.mFileName; }
@@ -181,11 +186,6 @@ protected:
         int compressionMethod);
 
     /*
-     * Set the modification date.
-     */
-    void setModWhen(time_t when);
-
-    /*
      * Return the offset of the local file header.
      */
     off_t getLFHOffset(void) const { return mCDE.mLocalHeaderRelOffset; }
-- 
2.7.0

